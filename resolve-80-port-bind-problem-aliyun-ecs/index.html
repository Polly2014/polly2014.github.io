<!doctype html><html><head><title>Polly Blog - AI Assistant, Tutorials, and Insights</title><meta content="Explore Polly Blog for AI tutorials, insights, and updates on cutting-edge technology." name=description><meta content="Polly, Blog, AI Blog, AI Assistant, Tutorials, Technology Blog, Baoli Wang" name=keywords><meta content="width=device-width,initial-scale=1" name=viewport><meta content="text/html; charset=utf-8" http-equiv=content-type><link rel="shortcut icon" href=https://polly.wang/images/polly.ico type=image/x-icon><link href=https://polly.wang/images/polly.ico rel=icon type=image/x-icon><link href=https://polly.wang/images/polly.ico rel=apple-touch-icon><link href=https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/grids-responsive-min.css rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css rel=stylesheet><link href=https://polly.wang/css/style_new.css rel=stylesheet><script src="https://www.googletagmanager.com/gtag/js?id=G-8JD13N7PHS" async></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date());gtag('config','G-8JD13N7PHS')</script><body><div class=menu-toggle><img alt=Menu src=https://polly.wang/images/polly.png></div><div class=overlay></div><div class="pure-g container"><div class="sidebar pure-u-1 pure-u-md-1-5"><div class=title><a class=pure-menu-heading href=https://polly.wang> <img class="avatar pure-img-responsive" src=https://polly.wang/images/polly.png> </a><div class=introduction><p>Polly's Blog</div><div class=nav><ul class=nav-links><li><a href=https://polly.wang><i class="fas fa-home"></i>Home</a><li><a href=https://polly.wang/archive><i class="fas fa-archive"></i>Archive</a><li><a href=https://polly.wang/category><i class="fas fa-folder"></i>Category</a><li><a href=https://polly.wang/blog><i class="fas fa-file-alt"></i>Posts</a><li><a href=https://polly.wang/publication><i class="fas fa-file-pdf"></i>Research</a><li><a href=https://polly.wang/changelog><i class="fas fa-history"></i>Change log</a><li><a href=https://polly.wang/about><i class="fas fa-info-circle"></i>About Me</a></ul></div><div class=social><ul class=social-links><li><a href=mailto:26716201@qq.com><i class="fas fa-envelope"></i></a><li><a href=https://twitter.com/Polly__007><i class="fab fa-twitter"></i></a><li><a href=https://www.linkedin.com/in/baoliwang><i class="fab fa-linkedin-in"></i></a><li><a href=https://github.com/Polly2014><i class="fab fa-github"></i></a></ul></div></div></div><div class="content pure-u-1 pure-u-md-4-5"><div class=blog-post><h1>阿里云ECS端口绑定权限问题：五种优雅的解决方案</h1><div class=content><p>最近在阿里云ECS上部署OpenHands项目（一个AI编程助手）时，遇到了一个常见但令人恼火的问题：应用程序无法绑定80端口。运行<code>make run</code>命令后，得到以下错误：<pre style=background:#2b303b;color:#c0c5ce><code><span>INFO:     Started server process [93385]
</span><span>INFO:     Waiting for application startup.
</span><span>INFO:     Application startup complete.
</span><span>ERROR:    [Errno 13] error while attempting to bind on address ('0.0.0.0', 80): permission denied
</span></code></pre><p>这个错误初看似乎很神秘，但实际上是Linux系统安全机制的正常表现：<strong>在Linux中，只有root用户才能绑定小于1024的端口</strong>。这是为了保护系统安全而设计的机制，因为这些低端口号（特别是常用的80、443等）通常用于关键服务。<p>经过一番研究和测试，我总结了五种解决方案，从简单临时的方法到适合生产环境的专业配置，下面我将详细分享这些方案的实施步骤和各自的优缺点。<h2 id=jie-jue-fang-an-dui-bi>解决方案对比</h2><table><thead><tr><th><strong>方案</strong><th><strong>复杂度</strong><th><strong>安全性</strong><th><strong>持久性</strong><th><strong>适用场景</strong><tbody><tr><td>修改应用端口<td>★☆☆☆☆<td>★★★★★<td>★★★★★<td>开发测试、简单应用<tr><td>使用sudo运行<td>★☆☆☆☆<td>★☆☆☆☆<td>★☆☆☆☆<td>临时测试、快速验证<tr><td>Nginx反向代理<td>★★★☆☆<td>★★★★★<td>★★★★★<td>生产环境、专业部署<tr><td>authbind授权<td>★★☆☆☆<td>★★★☆☆<td>★★★★☆<td>特定应用需要保留80端口<tr><td>systemd socket激活<td>★★★★☆<td>★★★★★<td>★★★★★<td>生产环境、系统级服务</table><h2 id=fang-an-yi-xiu-gai-ying-yong-pei-zhi-shi-yong-fei-te-quan-duan-kou>方案一：修改应用配置使用非特权端口</h2><p>这是最简单也最推荐的解决方法，特别是在开发和测试环境中。<h3 id=shi-shi-bu-zou>实施步骤：</h3><ol><li><p><strong>找到配置应用端口的文件</strong></p> <p>首先，我们需要找到OpenHands在哪里配置了端口：</p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#96b5b4>cd </span><span style=color:#bf616a>~</span><span>/GitHub_Workspace/pro-agent
</span><span style=color:#bf616a>grep -r </span><span>"</span><span style=color:#a3be8c>port</span><span>"</span><span style=color:#bf616a> --include</span><span>="</span><span style=color:#a3be8c>*.py</span><span>" .
</span></code></pre> <p>在我的情况下，发现端口配置在<code>server_config.py</code>文件中。</p><li><p><strong>修改端口配置</strong></p> <p>编辑配置文件，将端口从80改为8080（或其他大于1024的端口）：</p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>nano</span><span> server_config.py
</span></code></pre> <p>找到类似<code>PORT = 80</code>或<code>port = 80</code>的配置行，修改为：</p> <pre class=language-python data-lang=python style=background:#2b303b;color:#c0c5ce><code class=language-python data-lang=python><span style=color:#bf616a>PORT </span><span>= </span><span style=color:#d08770>8080  </span><span style=color:#65737e># 或其他大于1024的端口
</span></code></pre> <p>保存并退出。</p><li><p><strong>如果使用环境变量配置端口</strong></p> <p>有些应用使用环境变量配置，可以直接在运行时指定：</p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>PORT</span><span>=</span><span style=color:#a3be8c>8080 </span><span style=color:#bf616a>make</span><span> run
</span></code></pre> <p>或者修改<code>.env</code>文件（如果存在）：</p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#96b5b4>echo </span><span>"</span><span style=color:#a3be8c>PORT=8080</span><span>" >> .env
</span></code></pre><li><p><strong>重新运行应用</strong></p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>make</span><span> run
</span></code></pre> <p>这次应该能够成功启动在8080端口上。</p><li><p><strong>访问应用</strong></p> <p>现在可以通过<code>http://your-ecs-ip:8080</code>访问应用。</p></ol><h3 id=you-que-dian>优缺点：</h3><p><strong>优点</strong>：<ul><li>简单直接，无需特殊权限<li>不涉及系统配置修改，安全风险最低<li>适用于各种应用和框架</ul><p><strong>缺点</strong>：<ul><li>用户访问时需要指定非标准端口<li>对于某些要求使用标准HTTP端口的应用可能不适用</ul><h2 id=fang-an-er-shi-yong-sudoyun-xing-ying-yong-jin-xian-ce-shi>方案二：使用sudo运行应用（仅限测试）</h2><p>如果只是临时测试且你拥有sudo权限，可以用这种方法快速解决。<h3 id=shi-shi-bu-zou-1>实施步骤：</h3><ol><li><p><strong>直接用sudo运行</strong></p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>sudo</span><span> make run
</span></code></pre> <p>或者，如果你的应用有更具体的启动命令：</p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>sudo</span><span> python app.py
</span><span style=color:#65737e># 或
</span><span style=color:#bf616a>sudo</span><span> npm start
</span><span style=color:#65737e># 等等
</span></code></pre><li><p><strong>验证应用是否正常运行</strong></p> <p>服务应该能够成功绑定80端口并启动。</p></ol><h3 id=you-que-dian-1>优缺点：</h3><p><strong>优点</strong>：<ul><li>极其简单，一行命令解决<li>无需修改任何配置<li>速度快，适合临时测试</ul><p><strong>缺点</strong>：<ul><li>安全风险极高，绝不推荐用于生产环境<li>应用获得了root权限，可能导致安全漏洞<li>SSH断开后服务可能终止</ul><h2 id=fang-an-san-shi-yong-nginxfan-xiang-dai-li-tui-jian-sheng-chan-huan-jing>方案三：使用Nginx反向代理（推荐生产环境）</h2><p>这是专业且安全的解决方案，也是生产环境的最佳实践。<h3 id=shi-shi-bu-zou-2>实施步骤：</h3><ol><li><p><strong>安装Nginx</strong></p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>sudo</span><span> apt update
</span><span style=color:#bf616a>sudo</span><span> apt install nginx
</span></code></pre><li><p><strong>创建Nginx配置文件</strong></p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>sudo</span><span> nano /etc/nginx/sites-available/openhands
</span></code></pre> <p>添加以下内容：</p> <pre class=language-nginx data-lang=nginx style=background:#2b303b;color:#c0c5ce><code class=language-nginx data-lang=nginx><span>server {
</span><span>    listen 80;
</span><span>    server_name your-server-name-or-ip;
</span><span>
</span><span>    location / {
</span><span>        proxy_pass http://localhost:8080;
</span><span>        proxy_set_header Host $host;
</span><span>        proxy_set_header X-Real-IP $remote_addr;
</span><span>        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
</span><span>        proxy_set_header X-Forwarded-Proto $scheme;
</span><span>    }
</span><span>}
</span></code></pre> <p>替换<code>your-server-name-or-ip</code>为你的域名或ECS公网IP。</p><li><p><strong>启用配置</strong></p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>sudo</span><span> ln</span><span style=color:#bf616a> -s</span><span> /etc/nginx/sites-available/openhands /etc/nginx/sites-enabled/
</span><span style=color:#bf616a>sudo</span><span> nginx</span><span style=color:#bf616a> -t  </span><span style=color:#65737e># 测试配置是否有效
</span><span style=color:#bf616a>sudo</span><span> systemctl restart nginx
</span></code></pre><li><p><strong>修改应用配置使用8080端口</strong></p> <p>按照方案一中的步骤，修改你的应用配置，使其使用8080端口。</p><li><p><strong>启动应用</strong></p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>make</span><span> run
</span></code></pre><li><p><strong>设置应用自启动（可选）</strong></p> <p>为确保应用在系统重启后自动运行，可以创建服务文件：</p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>sudo</span><span> nano /etc/systemd/system/openhands.service
</span></code></pre> <p>添加内容：</p> <pre style=background:#2b303b;color:#c0c5ce><code><span>[Unit]
</span><span>Description=OpenHands AI Service
</span><span>After=network.target
</span><span>
</span><span>[Service]
</span><span>User=ecs-user
</span><span>WorkingDirectory=/home/ecs-user/GitHub_Workspace/pro-agent
</span><span>ExecStart=/usr/bin/make run
</span><span>Restart=always
</span><span>
</span><span>[Install]
</span><span>WantedBy=multi-user.target
</span></code></pre> <p>启用服务：</p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>sudo</span><span> systemctl enable openhands
</span><span style=color:#bf616a>sudo</span><span> systemctl start openhands
</span></code></pre></ol><h3 id=you-que-dian-2>优缺点：</h3><p><strong>优点</strong>：<ul><li>专业且安全的解决方案<li>允许在同一服务器上托管多个应用<li>提供额外的安全层和流量控制<li>支持SSL配置、负载均衡等高级功能</ul><p><strong>缺点</strong>：<ul><li>配置相对复杂<li>增加了一个额外的服务组件<li>略微增加系统资源消耗</ul><h2 id=fang-an-si-shi-yong-authbindyun-xu-fei-rootyong-hu-bang-ding-te-quan-duan-kou>方案四：使用authbind允许非root用户绑定特权端口</h2><p>如果你确实需要应用直接使用80端口，又不想用root权限运行，可以使用authbind。<h3 id=shi-shi-bu-zou-3>实施步骤：</h3><ol><li><p><strong>安装authbind</strong></p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>sudo</span><span> apt update
</span><span style=color:#bf616a>sudo</span><span> apt install authbind
</span></code></pre><li><p><strong>配置端口权限</strong></p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>sudo</span><span> touch /etc/authbind/byport/80
</span><span style=color:#bf616a>sudo</span><span> chmod 500 /etc/authbind/byport/80
</span><span style=color:#bf616a>sudo</span><span> chown $(</span><span style=color:#bf616a>whoami</span><span>) /etc/authbind/byport/80
</span></code></pre><li><p><strong>使用authbind运行应用</strong></p> <p>创建一个包装脚本：</p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>nano</span><span> run_with_authbind.sh
</span></code></pre> <p>添加以下内容：</p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#65737e>#!/bin/bash
</span><span style=color:#bf616a>authbind --deep</span><span> make run
</span></code></pre> <p>赋予执行权限：</p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>chmod</span><span> +x run_with_authbind.sh
</span></code></pre><li><p><strong>启动应用</strong></p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>./run_with_authbind.sh
</span></code></pre></ol><h3 id=you-que-dian-3>优缺点：</h3><p><strong>优点</strong>：<ul><li>允许非root用户使用特权端口<li>无需修改应用配置<li>安全性比sudo运行高</ul><p><strong>缺点</strong>：<ul><li>需要安装额外软件<li>配置过程较繁琐<li>需要为每个特权端口单独配置</ul><h2 id=fang-an-wu-shi-yong-systemd-socketji-huo>方案五：使用systemd socket激活</h2><p>这是最专业的解决方案，适合系统级服务和生产环境。<h3 id=shi-shi-bu-zou-4>实施步骤：</h3><ol><li><p><strong>创建socket单元文件</strong></p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>sudo</span><span> nano /etc/systemd/system/openhands.socket
</span></code></pre> <p>添加以下内容：</p> <pre style=background:#2b303b;color:#c0c5ce><code><span>[Unit]
</span><span>Description=OpenHands Socket
</span><span>
</span><span>[Socket]
</span><span>ListenStream=80
</span><span>NoDelay=true
</span><span>
</span><span>[Install]
</span><span>WantedBy=sockets.target
</span></code></pre><li><p><strong>创建服务单元文件</strong></p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>sudo</span><span> nano /etc/systemd/system/openhands.service
</span></code></pre> <p>添加以下内容：</p> <pre style=background:#2b303b;color:#c0c5ce><code><span>[Unit]
</span><span>Description=OpenHands Service
</span><span>Requires=openhands.socket
</span><span>After=network.target
</span><span>
</span><span>[Service]
</span><span>User=ecs-user
</span><span>WorkingDirectory=/home/ecs-user/GitHub_Workspace/pro-agent
</span><span>ExecStart=/usr/bin/make run
</span><span>StandardInput=socket
</span><span>
</span><span>[Install]
</span><span>WantedBy=multi-user.target
</span></code></pre><li><p><strong>启用并启动socket</strong></p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>sudo</span><span> systemctl enable openhands.socket
</span><span style=color:#bf616a>sudo</span><span> systemctl start openhands.socket
</span></code></pre><li><p><strong>检查状态</strong></p> <pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>sudo</span><span> systemctl status openhands.socket
</span><span style=color:#bf616a>sudo</span><span> systemctl status openhands.service
</span></code></pre><li><p><strong>需要修改应用代码（可能）</strong></p> <p>对于某些应用，你可能需要修改它们以支持从systemd socket接收连接。这取决于应用的具体实现。</p></ol><h3 id=you-que-dian-4>优缺点：</h3><p><strong>优点</strong>：<ul><li>最专业的系统级解决方案<li>支持socket激活（按需启动）<li>完全集成到系统服务管理中<li>安全且可靠</ul><p><strong>缺点</strong>：<ul><li>配置最复杂<li>可能需要修改应用代码以支持socket激活<li>学习曲线较陡峭</ul><h2 id=chang-jian-wen-ti-yu-jie-jue-fang-fa>常见问题与解决方法</h2><p>在实施上述方案的过程中，我遇到了一些常见问题，分享给大家：<h3 id=1-ying-yong-qi-dong-cheng-gong-dan-wu-fa-fang-wen>1. 应用启动成功但无法访问</h3><p>检查防火墙设置：<pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>sudo</span><span> iptables</span><span style=color:#bf616a> -L
</span><span style=color:#65737e># 如果需要开放端口
</span><span style=color:#bf616a>sudo</span><span> iptables</span><span style=color:#bf616a> -A</span><span> INPUT</span><span style=color:#bf616a> -p</span><span> tcp</span><span style=color:#bf616a> --dport</span><span> 80</span><span style=color:#bf616a> -j</span><span> ACCEPT
</span><span style=color:#bf616a>sudo</span><span> iptables</span><span style=color:#bf616a> -A</span><span> INPUT</span><span style=color:#bf616a> -p</span><span> tcp</span><span style=color:#bf616a> --dport</span><span> 8080</span><span style=color:#bf616a> -j</span><span> ACCEPT
</span></code></pre><p>对于使用ufw的系统：<pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>sudo</span><span> ufw allow 80/tcp
</span><span style=color:#bf616a>sudo</span><span> ufw allow 8080/tcp
</span></code></pre><h3 id=2-nginxpei-zhi-hou-chu-xian-502cuo-wu>2. Nginx配置后出现502错误</h3><p>这通常意味着Nginx无法连接到你的应用：<ul><li>确认应用确实在运行：<code>ps aux | grep your-app</code><li>检查应用绑定的是否为127.0.0.1而不是localhost<li>查看Nginx错误日志：<code>sudo tail -f /var/log/nginx/error.log</code></ul><h3 id=3-systemd-socketji-huo-bu-gong-zuo>3. systemd socket激活不工作</h3><p>检查应用是否支持从systemd接收socket：<pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>sudo</span><span> journalctl</span><span style=color:#bf616a> -u</span><span> openhands.service
</span></code></pre><p>可能需要调整应用启动参数来支持socket激活。<h2 id=wo-de-xuan-ze-yu-shi-jian-jing-yan>我的选择与实践经验</h2><p>经过多次测试和长期使用，我最终选择了**方案三（Nginx反向代理）**作为生产环境解决方案，原因如下：<ol><li><strong>安全性</strong>：应用以非特权用户运行，减少安全风险<li><strong>灵活性</strong>：可以轻松配置SSL、缓存、负载均衡等高级功能<li><strong>标准化</strong>：这是业界公认的最佳实践<li><strong>多应用支持</strong>：可以在同一服务器上托管多个应用</ol><p>对于开发环境，我通常使用<strong>方案一（修改端口）</strong>，简单直接且无需额外配置。<p>无论你选择哪种方案，记住在生产环境中绝不要使用方案二（sudo运行）！这是一个危险的做法，可能导致严重的安全问题。<h2 id=zong-jie>总结</h2><p>在阿里云ECS上无法绑定80端口是一个常见问题，反映了Linux系统的安全设计。根据你的需求和技术水平，可以选择上述五种方案之一：<ul><li><strong>最简单解决方案</strong>：修改应用使用8080等非特权端口<li><strong>最专业生产方案</strong>：Nginx反向代理 + 应用使用非特权端口<li><strong>最干净系统方案</strong>：systemd socket激活</ul><p>希望这篇博文能帮助你解决在阿里云ECS上部署Web应用时遇到的端口绑定问题。如有任何疑问或更好的解决方案，欢迎在评论区分享！</div><div class=navigation></div></div><div id=giscus-container><h2>留言与讨论</h2><div class=giscus></div></div><script data-category="Blog Comments" async crossorigin data-category-id=DIC_kwDOL45duM4CnjlZ data-emit-metadata=0 data-input-position=bottom data-lang=en data-mapping=pathname data-reactions-enabled=1 data-repo=Polly2014/polly2014.github.io data-repo-id=R_kgDOL45duA data-strict=0 data-theme=noborder_light src=https://giscus.app/client.js></script><script type=module>
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        
        mermaid.initialize({
            startOnLoad: false,
            theme: 'dark',
            themeVariables: {
                primaryColor: '#a855f7',
                primaryTextColor: '#fff',
                primaryBorderColor: '#a855f7',
                lineColor: '#06b6d4',
                secondaryColor: '#16213e',
                tertiaryColor: '#1a1a2e',
                background: '#0f0f1a',
                mainBkg: '#1a1a2e',
                nodeBorder: '#a855f7',
                clusterBkg: '#16213e',
                clusterBorder: '#a855f7',
                titleColor: '#ec4899',
                edgeLabelBackground: '#1a1a2e'
            },
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            }
        });

        // 查找所有 mermaid 代码块并渲染
        document.querySelectorAll('pre code.language-mermaid').forEach((block, index) => {
            const container = document.createElement('div');
            container.className = 'mermaid';
            container.textContent = block.textContent;
            block.parentNode.replaceWith(container);
        });

        // 渲染所有 mermaid 图表
        await mermaid.run();
    </script><style>.mermaid{background:#1a1a2e;border:1px solid #a855f7;border-radius:8px;padding:20px;margin:20px 0;overflow-x:auto}.mermaid svg{max-width:100%;height:auto}</style></div></div><script>document.addEventListener('DOMContentLoaded',function(){const c=document.querySelector('.menu-toggle');const d=document.querySelector('.sidebar');const e=document.querySelector('.overlay');function a(){d.classList.toggle('active');e.classList.toggle('active')}c.addEventListener('click',a);e.addEventListener('click',a);let f=0;let g=0;document.addEventListener('touchstart',h=>{f=h.changedTouches[0].screenX},false);document.addEventListener('touchend',h=>{g=h.changedTouches[0].screenX;b()},false);function b(){const h=g- f;if(h>50&&f<30){d.classList.add('active');e.classList.add('active')}else if(h<-50&&d.classList.contains('active')){d.classList.remove('active');e.classList.remove('active')}}})</script>