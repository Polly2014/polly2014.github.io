<!doctype html><html><head><title>Polly Blog - AI Assistant, Tutorials, and Insights</title><meta content="Explore Polly Blog for AI tutorials, insights, and updates on cutting-edge technology." name=description><meta content="Polly, Blog, AI Blog, AI Assistant, Tutorials, Technology Blog, Baoli Wang" name=keywords><meta content="width=device-width,initial-scale=1" name=viewport><meta content="text/html; charset=utf-8" http-equiv=content-type><link rel="shortcut icon" href=https://polly.wang/images/polly.ico type=image/x-icon><link href=https://polly.wang/images/polly.ico rel=icon type=image/x-icon><link href=https://polly.wang/images/polly.ico rel=apple-touch-icon><link href=https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/grids-responsive-min.css rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css rel=stylesheet><link href=https://polly.wang/css/style_new.css rel=stylesheet><script src="https://www.googletagmanager.com/gtag/js?id=G-8JD13N7PHS" async></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date());gtag('config','G-8JD13N7PHS')</script><body><div class=menu-toggle><img alt=Menu src=https://polly.wang/images/polly.png></div><div class=overlay></div><div class="pure-g container"><div class="sidebar pure-u-1 pure-u-md-1-5"><div class=title><a class=pure-menu-heading href=https://polly.wang> <img class="avatar pure-img-responsive" src=https://polly.wang/images/polly.png> </a><div class=introduction><p>Polly's Blog</div><div class=nav><ul class=nav-links><li><a href=https://polly.wang><i class="fas fa-home"></i>Home</a><li><a href=https://polly.wang/archive><i class="fas fa-archive"></i>Archive</a><li><a href=https://polly.wang/category><i class="fas fa-folder"></i>Category</a><li><a href=https://polly.wang/blog><i class="fas fa-file-alt"></i>Posts</a><li><a href=https://polly.wang/publication><i class="fas fa-file-pdf"></i>Research</a><li><a href=https://polly.wang/changelog><i class="fas fa-history"></i>Change log</a><li><a href=https://polly.wang/about><i class="fas fa-info-circle"></i>About Me</a></ul></div><div class=social><ul class=social-links><li><a href=mailto:26716201@qq.com><i class="fas fa-envelope"></i></a><li><a href=https://twitter.com/Polly__007><i class="fab fa-twitter"></i></a><li><a href=https://www.linkedin.com/in/baoliwang><i class="fab fa-linkedin-in"></i></a><li><a href=https://github.com/Polly2014><i class="fab fa-github"></i></a></ul></div></div></div><div class="content pure-u-1 pure-u-md-4-5"><div class=blog-post><h1>JPEG XS的并行化改造方案与实现</h1><div class=content><h2 id=bei-jing-jie-shao>背景介绍</h2><p>JPEG XS是一种低延迟、视觉无损的图像压缩标准，广泛应用于实时视频传输和高质量图像处理。其参考软件实现了编码和解码功能，但目前的实现是串行的，存在性能优化的空间。本次任务旨在分析其并行化的可能性，并给出详尽的并行化思路、方案与代码。<hr><h2 id=bian-jie-ma-guo-cheng-fen-xi>编解码过程分析</h2><h3 id=bian-ma-guo-cheng>编码过程</h3><ol><li><strong>输入图像预处理</strong>：支持PNM、PGX、YUV等格式。<li><strong>配置编码参数</strong>：包括配置文件、比特率等。<li><strong>小波变换</strong>：分解图像为多个频率子带。<li><strong>量化</strong>：减少数据冗余。<li><strong>熵编码</strong>：压缩量化后的数据。<li><strong>码流生成</strong>：生成符合ISO标准的JPEG XS码流。</ol><h3 id=jie-ma-guo-cheng>解码过程</h3><ol><li><strong>读取码流</strong>：解析JPEG XS码流结构。<li><strong>熵解码</strong>：恢复量化数据。<li><strong>逆量化</strong>：还原小波系数。<li><strong>逆小波变换</strong>：重建图像像素数据。<li><strong>色彩空间转换</strong>：还原RGB或YUV格式。</ol><hr><h2 id=bing-xing-hua-gai-zao-si-lu>并行化改造思路</h2><h3 id=chuan-xing-yu-bing-xing-fen-xi>串行与并行分析</h3><ul><li><strong>现状</strong>：编码和解码过程是串行的。<li><strong>优化可能性</strong>：编码过程的每一列是独立的，具有并行化潜力。</ul><h3 id=bing-xing-hua-fang-an>并行化方案</h3><h4 id=1-bing-xing-hua-lie-chu-li>1. 并行化列处理</h4><ul><li><strong>现状</strong>：列的初始化是通过循环逐列完成的。<li><strong>改造思路</strong>：使用OpenMP将列的初始化并行化。<li><strong>代码实现</strong>：<pre class=language-c data-lang=c style=background:#2b303b;color:#c0c5ce><code class=language-c data-lang=c><span style=color:#b48ead>#pragma</span><span> omp parallel for
</span><span style=color:#b48ead>for </span><span>(</span><span style=color:#b48ead>int</span><span> column = </span><span style=color:#d08770>0</span><span>; column < ctx->ids.</span><span style=color:#bf616a>npx</span><span>; column++) {
</span><span>    ctx->rc[column] = </span><span style=color:#bf616a>rate_control_open</span><span>(xs_config, &ctx->ids, column);
</span><span>    ctx->precinct[column] = </span><span style=color:#bf616a>precinct_open_column</span><span>(&ctx->ids, ctx->xs_config->p.</span><span style=color:#bf616a>N_g</span><span>, column);
</span><span>}
</span></code></pre></ul><h4 id=2-bing-xing-hua-xiao-bo-bian-huan>2. 并行化小波变换</h4><ul><li><strong>现状</strong>：小波变换是逐行逐列处理的。<li><strong>改造思路</strong>：将小波变换的行处理并行化。<li><strong>代码实现</strong>：<pre class=language-c data-lang=c style=background:#2b303b;color:#c0c5ce><code class=language-c data-lang=c><span style=color:#b48ead>#pragma</span><span> omp parallel for
</span><span style=color:#b48ead>for </span><span>(</span><span style=color:#b48ead>int</span><span> y = </span><span style=color:#d08770>0</span><span>; y < height; y++) {
</span><span>    </span><span style=color:#b48ead>for </span><span>(</span><span style=color:#b48ead>int</span><span> x = </span><span style=color:#d08770>0</span><span>; x < width; x++) {
</span><span>        output[y][x] = </span><span style=color:#bf616a>perform_wavelet_transform</span><span>(input, y, x);
</span><span>    }
</span><span>}
</span></code></pre></ul><h4 id=3-gpujia-su>3. GPU加速</h4><ul><li><strong>现状</strong>：当前实现基于CPU。<li><strong>改造思路</strong>：使用CUDA或OpenCL将小波变换、量化和熵编码移植到GPU。<li><strong>优势</strong>：GPU擅长处理大规模并行任务，适合图像分块处理。</ul><hr><h2 id=bian-yi-zhi-chi-openmp>编译支持OpenMP</h2><h3 id=xiu-gai-cmakelists-txt>修改<code>CMakeLists.txt</code></h3><ul><li>添加以下内容以支持OpenMP：<pre class=language-cmake data-lang=cmake style=background:#2b303b;color:#c0c5ce><code class=language-cmake data-lang=cmake><span style=color:#96b5b4>find_package</span><span>(OpenMP </span><span style=color:#bf616a>REQUIRED</span><span>)
</span><span style=color:#b48ead>if </span><span>(OpenMP_CXX_FOUND)
</span><span>    </span><span style=color:#96b5b4>target_link_libraries</span><span>(jxs </span><span style=color:#bf616a>PRIVATE </span><span>OpenMP::OpenMP_CXX)
</span><span style=color:#b48ead>endif</span><span>()
</span></code></pre></ul><h3 id=shi-yong-gccbian-yi>使用<code>gcc</code>编译</h3><ul><li>添加<code>-fopenmp</code>选项：<pre class=language-bash data-lang=bash style=background:#2b303b;color:#c0c5ce><code class=language-bash data-lang=bash><span style=color:#bf616a>gcc -fopenmp -o</span><span> jxs_encoder xs_enc.c</span><span style=color:#bf616a> -lm
</span></code></pre></ul><hr><h2 id=zong-jie>总结</h2><p>通过上述并行化改造，可以显著提升JPEG XS参考软件的编解码性能。主要改动包括：<ul><li>使用OpenMP并行化列处理和小波变换。<li>修改编译配置以支持多线程。<li>考虑使用GPU加速核心计算。</ul><p>如果需要进一步优化或测试并行化效果，可以继续探索具体模块的实现。</div><div class=navigation></div></div><div id=giscus-container><h2>留言与讨论</h2><div class=giscus></div></div><script data-category="Blog Comments" async crossorigin data-category-id=DIC_kwDOL45duM4CnjlZ data-emit-metadata=0 data-input-position=bottom data-lang=en data-mapping=pathname data-reactions-enabled=1 data-repo=Polly2014/polly2014.github.io data-repo-id=R_kgDOL45duA data-strict=0 data-theme=noborder_light src=https://giscus.app/client.js></script></div></div><script>document.addEventListener('DOMContentLoaded',function(){const c=document.querySelector('.menu-toggle');const d=document.querySelector('.sidebar');const e=document.querySelector('.overlay');function a(){d.classList.toggle('active');e.classList.toggle('active')}c.addEventListener('click',a);e.addEventListener('click',a);let f=0;let g=0;document.addEventListener('touchstart',h=>{f=h.changedTouches[0].screenX},false);document.addEventListener('touchend',h=>{g=h.changedTouches[0].screenX;b()},false);function b(){const h=g- f;if(h>50&&f<30){d.classList.add('active');e.classList.add('active')}else if(h<-50&&d.classList.contains('active')){d.classList.remove('active');e.classList.remove('active')}}})</script>